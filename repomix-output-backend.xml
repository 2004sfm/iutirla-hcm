This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/models.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
accounts/
  models.py
ats/
  models.py
core/
  models.py
employment/
  models.py
organization/
  models.py
performance/
  models.py
recruitment/
  models.py
talent/
  models.py
training/
  models.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="accounts/models.py">
from django.db import models
from django.contrib.auth.models import (
    AbstractBaseUser, BaseUserManager, PermissionsMixin
)
from core.models import Person

class UserManager(BaseUserManager):
    def create_user(self, username, password=None, **extra_fields):
        if not username:
            raise ValueError('El campo Username es obligatorio')
        
        # Normalización básica
        username = username.strip().lower()
        user = self.model(username=username, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, username, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_active', True)

        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')
        extra_fields.setdefault('person', None) 
        
        return self.create_user(username, password, **extra_fields)

class User(AbstractBaseUser, PermissionsMixin):
    person = models.OneToOneField(
        Person, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name='user_account' # Permite acceder desde Person: person.user_account
    )
    username = models.CharField(
        max_length=100, 
        unique=True,
        error_messages={
            'unique': "Este nombre de usuario ya está registrado.",
            'blank': "El nombre de usuario es obligatorio."
        }
    )
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    objects = UserManager()
    
    USERNAME_FIELD = 'username'
    REQUIRED_FIELDS = []

    def __str__(self):
        return self.username
</file>

<file path="ats/models.py">
from django.db import models
from django.core.exceptions import ValidationError
from django.utils import timezone
from django.conf import settings
from simple_history.models import HistoricalRecords
from organization.models import Position, Department

# Mensajes de error estándar
UNIQUE_ERR_MSG = {'unique': "Ya existe un registro con este nombre."}


class JobPosting(models.Model):
    """Vacante publicable con configuración dinámica de formulario"""
    
    STATUS_CHOICES = [
        ('DRAFT', 'Borrador'),
        ('PUBLISHED', 'Publicada'),
        ('CLOSED', 'Cerrada'),
        ('FROZEN', 'Congelada'),
    ]
    
    # Información básica
    title = models.CharField(
        max_length=200,
        verbose_name="Título de la Vacante",
        help_text="Ej: Desarrollador Frontend Senior"
    )
    description = models.TextField(
        verbose_name="Descripción",
        help_text="Descripción completa de la vacante"
    )
    
    # Relaciones
    position = models.ForeignKey(
        Position,
        on_delete=models.SET_NULL,
        null=True,
        verbose_name="Posición",
        help_text="Posición organizacional a la que corresponde"
    )
    
    # Detalles de la oferta
    location = models.CharField(
        max_length=200,
        blank=True,
        null=True,
        verbose_name="Ubicación",
        help_text="Ej: Caracas, Venezuela / Remoto"
    )
    
    # Configuración dinámica del formulario público
    ask_education = models.BooleanField(
        default=False,
        verbose_name="Solicitar Educación",
        help_text="¿El formulario debe pedir información educativa?"
    )

    
    # Estado y fechas
    status = models.CharField(
        max_length=10,
        choices=STATUS_CHOICES,
        default='DRAFT',
        verbose_name="Estado"
    )
    published_date = models.DateField(
        null=True,
        blank=True,
        verbose_name="Fecha de Publicación"
    )
    closing_date = models.DateField(
        null=True,
        blank=True,
        verbose_name="Fecha de Cierre"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Historial de cambios
    history = HistoricalRecords()
    
    class Meta:
        verbose_name = "Vacante"
        verbose_name_plural = "Vacantes"
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.title} ({self.get_status_display()})"
    
    def clean(self):
        """Validaciones personalizadas"""
        if self.status == 'PUBLISHED' and not self.published_date:
            self.published_date = timezone.now().date()
        
        if self.closing_date and self.published_date:
            if self.closing_date < self.published_date:
                raise ValidationError("La fecha de cierre no puede ser anterior a la de publicación")
    
    def save(self, *args, **kwargs):
        self.clean()
        super().save(*args, **kwargs)


class Candidate(models.Model):
    """Candidato temporal (no es empleado aún)"""
    
    STAGE_CHOICES = [
        ('NEW', 'Nuevo'),
        ('REV', 'En Revisión'),
        ('INT', 'Entrevista/Pruebas'),
        ('OFF', 'Oferta Enviada'),
        ('HIRED', 'Contratado'),
        ('REJ', 'Rechazado'),
        ('POOL', 'Banco de Elegibles'),
    ]
    
    # Relación con la vacante
    job_posting = models.ForeignKey(
        JobPosting,
        on_delete=models.CASCADE,
        related_name='candidates',
        verbose_name="Vacante"
    )
    
    # Datos personales básicos
    first_name = models.CharField(
        max_length=100,
        verbose_name="Nombre"
    )
    last_name = models.CharField(
        max_length=100,
        verbose_name="Apellido"
    )
    email = models.EmailField(
        verbose_name="Correo Electrónico"
    )
    
    # Teléfono - Nuevo formato (separado)
    phone_area_code = models.ForeignKey(
        'core.PhoneCarrierCode',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name="Código de Área"
    )
    phone_subscriber = models.CharField(
        max_length=10,
        blank=True,
        null=True,
        verbose_name="Número de Suscriptor"
    )
    
    # Teléfono - Formato antiguo (para retrocompatibilidad)
    phone = models.CharField(
        max_length=20,
        blank=True,
        null=True,
        verbose_name="Teléfono (Completo)"
    )
    
    national_id = models.CharField(
        max_length=20,
        verbose_name="Cédula/ID Nacional",
        help_text="Documento de identidad"
    )
    
    avatar = models.ImageField(
        upload_to='candidates/avatars/',
        null=True,
        blank=True,
        verbose_name="Foto de Perfil"
    )
    
    # CV obligatorio
    cv_file = models.FileField(
        upload_to='candidates/cv/',
        verbose_name="Currículum (PDF)",
        help_text="Archivo PDF del currículum"
    )
    
    # Campos dinámicos opcionales (según configuración de JobPosting)
    education_details = models.TextField(
        blank=True,
        null=True,
        verbose_name="Detalles de Educación",
        help_text="Información educativa (JSON o texto)"
    )
    
    # Pipeline (máquina de estados)
    stage = models.CharField(
        max_length=5,
        choices=STAGE_CHOICES,
        default='NEW',
        verbose_name="Etapa"
    )
    
    # Notas del reclutador
    notes = models.TextField(
        blank=True,
        null=True,
        verbose_name="Notas Internas",
        help_text="Comentarios del reclutador sobre el candidato"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Historial de cambios
    history = HistoricalRecords()
    
    class Meta:
        verbose_name = "Candidato"
        verbose_name_plural = "Candidatos"
        ordering = ['-created_at']
        # Evitar duplicados: misma persona aplicando a la misma vacante
        unique_together = [('job_posting', 'email')]
    
    def __str__(self):
        return f"{self.first_name} {self.last_name} - {self.job_posting.title}"

    def save(self, *args, **kwargs):
        # Auto-populate legacy phone field
        if self.phone_area_code and self.phone_subscriber:
            self.phone = f"{self.phone_area_code.code}-{self.phone_subscriber}"
        super().save(*args, **kwargs)


class CandidateEducation(models.Model):
    """Educación del candidato (se migrará a PersonEducation al contratar)"""
    
    candidate = models.ForeignKey(
        Candidate,
        on_delete=models.CASCADE,
        related_name='education',
        verbose_name="Candidato"
    )
    
    school_name = models.CharField(
        max_length=255,
        verbose_name="Institución"
    )
    level_name = models.CharField(
        max_length=100,
        verbose_name="Nivel Educativo",
        help_text="Ej: Ingeniería, Licenciatura, Maestría"
    )
    field_name = models.CharField(
        max_length=100,
        verbose_name="Área de Estudio",
        help_text="Ej: Informática, Administración"
    )
    start_date = models.DateField(
        verbose_name="Fecha de Inicio"
    )
    end_date = models.DateField(
        null=True,
        blank=True,
        verbose_name="Fecha de Finalización",
        help_text="Dejar vacío si está en curso"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = "Educación de Candidato"
        verbose_name_plural = "Educación de Candidatos"
        ordering = ['-start_date']
    
    def __str__(self):
        return f"{self.school_name} - {self.level_name}"


class CandidateLog(models.Model):
    """Registro de auditoría para cambios en candidatos"""
    
    candidate = models.ForeignKey(
        Candidate,
        on_delete=models.CASCADE,
        related_name='logs',
        verbose_name="Candidato"
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name="Usuario"
    )
    action = models.CharField(
        max_length=50,
        verbose_name="Acción"
    )
    details = models.TextField(
        blank=True,
        null=True,
        verbose_name="Detalles"
    )
    timestamp = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        verbose_name = "Registro de Actividad"
        verbose_name_plural = "Registros de Actividad"
        ordering = ['-timestamp']
    
    def __str__(self):
        return f"{self.candidate} - {self.action} - {self.timestamp}"
</file>

<file path="core/models.py">
from django.db import models
from simple_history.models import HistoricalRecords

# Configuración base para mensajes de error
UNIQUE_ERR_MSG = {'unique': "Ya existe un registro con este nombre."}
ISO_UNIQUE_ERR_MSG = {'unique': "Ya existe un registro con este código ISO."}
CODE_UNIQUE_ERR_MSG = {'unique': "Ya existe un registro con este código."}
EMAIL_UNIQUE_ERR_MSG = {'unique': "Este correo electrónico ya está registrado."}

# --- CATÁLOGOS BÁSICOS ---
class Gender(models.Model):
    name = models.CharField(max_length=50, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class MaritalStatus(models.Model):
    name = models.CharField(max_length=50, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class Country(models.Model):
    name = models.CharField(max_length=100, unique=True, error_messages=UNIQUE_ERR_MSG)
    iso_2 = models.CharField(max_length=2, help_text="Ej: US, VE.", unique=True, error_messages=ISO_UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class DisabilityGroup(models.Model):
    name = models.CharField(max_length=100, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class DisabilityType(models.Model):
    name = models.CharField(max_length=100, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class DisabilityStatus(models.Model):
    name = models.CharField(max_length=50, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class AddressType(models.Model):
    name = models.CharField(max_length=50, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class EmailType(models.Model):
    name = models.CharField(max_length=50, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class PhoneType(models.Model):
    name = models.CharField(max_length=50, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class PhoneCarrier(models.Model):
    name = models.CharField(max_length=50, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class Bank(models.Model):
    name = models.CharField(max_length=100, unique=True, error_messages=UNIQUE_ERR_MSG)
    code = models.CharField(max_length=4, unique=True, error_messages=CODE_UNIQUE_ERR_MSG)
    def __str__(self): return f"{self.name} ({self.code})"

class BankAccountType(models.Model):
    name = models.CharField(max_length=50, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class RelationshipType(models.Model):
    name = models.CharField(max_length=50, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

# --- MODELOS RELACIONALES ---

class State(models.Model):
    name = models.CharField(max_length=100)
    country = models.ForeignKey(Country, on_delete=models.CASCADE)
    class Meta: unique_together = ('country', 'name')
    def __str__(self): return f"{self.name}, {self.country.name}"

class PhoneCarrierCode(models.Model):
    carrier = models.ForeignKey(PhoneCarrier, on_delete=models.CASCADE)
    code = models.CharField(max_length=4)
    class Meta: unique_together = ('carrier', 'code')
    def __str__(self): return f"{self.code} ({self.carrier})"

class Person(models.Model):
    first_name = models.CharField(max_length=100)
    second_name = models.CharField(max_length=100, blank=True, null=True)
    paternal_surname = models.CharField(max_length=100)
    maternal_surname = models.CharField(max_length=100, blank=True, null=True)
    gender = models.ForeignKey(Gender, on_delete=models.PROTECT, null=True, blank=True)
    marital_status = models.ForeignKey(MaritalStatus, on_delete=models.SET_NULL, null=True, blank=True)
    birthdate = models.DateField(null=True, blank=True)
    country_of_birth = models.ForeignKey(Country, on_delete=models.SET_NULL, null=True, blank=True)
    photo = models.ImageField(upload_to='photos/person/', null=True, blank=True)
    cv_file = models.FileField(upload_to='cv/person/', null=True, blank=True, help_text="Curriculum Vitae (PDF, DOCX)")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Historial de cambios
    history = HistoricalRecords()
    
    def __str__(self): return f"{self.first_name} {self.paternal_surname}"

# --- IDENTIFICACIÓN VENEZOLANA ROBUSTA ---
class NationalId(models.Model):
    # ... (campos igual que antes) ...
    CATEGORY_CHOICES = [
        ('CEDULA', 'Cédula de Identidad'),
        ('RIF', 'RIF'),
        ('PASSPORT', 'Pasaporte'),
    ]

    PREFIX_CHOICES = [
        ('V', 'V - Venezolano / Persona Natural'),
        ('E', 'E - Extranjero / Persona Natural'),
        ('J', 'J - Jurídico'),
        ('G', 'G - Gubernamental'),
        ('P', 'P - Pasaporte'),
    ]

    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="national_ids")
    
    category = models.CharField(max_length=10, choices=CATEGORY_CHOICES, default='CEDULA')
    document_type = models.CharField(max_length=1, choices=PREFIX_CHOICES, default='V', verbose_name="Prefijo")
    number = models.CharField(max_length=20, help_text="Solo números.")
    
    is_primary = models.BooleanField(default=False)
    file = models.FileField(upload_to='documents/national_id/', blank=True, null=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        unique_together = [
            # REGLA 1: Nadie más puede tener este documento en el sistema
            ('document_type', 'number'),
            
            # REGLA 2: Esta persona solo puede tener UNO de cada categoría
            ('person', 'category'),
        ]

    def save(self, *args, **kwargs):
        # La cédula siempre es el documento principal
        if self.category == 'CEDULA':
            self.is_primary = True
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.get_category_display()}: {self.document_type}-{self.number}"

# --- DETALLES DE PERSONA ---

class PersonDisabilityVE(models.Model):
    person = models.OneToOneField(Person, on_delete=models.CASCADE, primary_key=True)
    date_learned = models.DateField(null=True, blank=True)
    disability_group = models.ForeignKey(DisabilityGroup, on_delete=models.SET_NULL, null=True, blank=True)
    disability_degree = models.CharField(max_length=50, blank=True, null=True)
    disability_type = models.ForeignKey(DisabilityType, on_delete=models.SET_NULL, null=True, blank=True)
    issuing_authority = models.CharField(max_length=100, blank=True, null=True)
    reference_number = models.CharField(max_length=50, blank=True, null=True)
    disability_status = models.ForeignKey(DisabilityStatus, on_delete=models.SET_NULL, null=True, blank=True)
    date_of_determination = models.DateField(null=True, blank=True)

class Address(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="addresses")
    address_type = models.ForeignKey(AddressType, on_delete=models.SET_NULL, null=True)
    country = models.ForeignKey(Country, on_delete=models.SET_NULL, null=True)
    state = models.ForeignKey(State, on_delete=models.SET_NULL, null=True)
    city = models.CharField(max_length=100)
    postal_code = models.CharField(max_length=20, blank=True, null=True)
    street_name_and_number = models.CharField(max_length=255)
    extra_address_line = models.CharField(max_length=255, blank=True, null=True)
    house_number = models.CharField(max_length=50, blank=True, null=True)
    apartment = models.CharField(max_length=50, blank=True, null=True)
    street_2 = models.CharField(max_length=255, blank=True, null=True)

class PersonEmail(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="emails")
    email_type = models.ForeignKey(EmailType, on_delete=models.SET_NULL, null=True)
    email_address = models.EmailField(unique=True, error_messages=EMAIL_UNIQUE_ERR_MSG) 
    is_primary = models.BooleanField(default=False)
    
    def __str__(self): 
        return self.email_address

class PersonPhone(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="phones")
    phone_type = models.ForeignKey(PhoneType, on_delete=models.SET_NULL, null=True)
    carrier_code = models.ForeignKey(PhoneCarrierCode, on_delete=models.SET_NULL, null=True)
    subscriber_number = models.CharField(max_length=10)
    is_primary = models.BooleanField(default=False)
    
    def __str__(self): return f"{self.carrier_code.code}-{self.subscriber_number}"
    
    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=['carrier_code', 'subscriber_number'],
                name="phone_unique",
                violation_error_message="Este número de teléfono ya se encuentra registrado.",
            ),
            models.UniqueConstraint(
                fields=['person'],
                condition=models.Q(is_primary=True),
                name='one_primary_phone_per_person',
                violation_error_message="La persona ya tiene un teléfono principal registrado.",
            ),
        ]

class PersonBankAccount(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="bank_accounts")
    bank = models.ForeignKey(Bank, on_delete=models.SET_NULL, null=True)
    bank_account_type = models.ForeignKey(BankAccountType, on_delete=models.SET_NULL, null=True)
    account_number = models.CharField(max_length=20, unique=True, error_messages={'unique': "Este número de cuenta ya está registrado."})
    is_primary = models.BooleanField(default=False)

class PersonDocument(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="documents")
    file = models.FileField(upload_to='documents/person/', blank=True, null=True)
    description = models.CharField(max_length=255, blank=True, null=True)

class PersonNationality(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="nationalities")
    country = models.ForeignKey(Country, on_delete=models.CASCADE)
    class Meta: unique_together = ('person', 'country')

# --- SATÉLITES ---
class Dependent(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="dependents")
    first_name = models.CharField(max_length=100)
    second_name = models.CharField(max_length=100, blank=True, null=True)
    paternal_surname = models.CharField(max_length=100)
    maternal_surname = models.CharField(max_length=100, blank=True, null=True)
    relationship = models.ForeignKey(RelationshipType, on_delete=models.SET_NULL, null=True)
    birthdate = models.DateField()
    gender = models.ForeignKey(Gender, on_delete=models.SET_NULL, null=True, blank=True)
    class Meta: unique_together = ('person', 'first_name', 'paternal_surname')

class EmergencyContact(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="emergency_contacts")
    first_name = models.CharField(max_length=100)
    second_name = models.CharField(max_length=100, blank=True, null=True)
    paternal_surname = models.CharField(max_length=100)
    maternal_surname = models.CharField(max_length=100, blank=True, null=True)
    relationship = models.ForeignKey(RelationshipType, on_delete=models.SET_NULL, null=True)
    phone_carrier_code = models.ForeignKey(PhoneCarrierCode, on_delete=models.SET_NULL, null=True)
    phone_number = models.CharField(max_length=10)
    is_primary = models.BooleanField(default=False)
</file>

<file path="employment/models.py">
from django.db import models
from django.core.exceptions import ValidationError
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from simple_history.models import HistoricalRecords

# Importaciones de otras apps
from core.models import Person
from organization.models import Position

# Configuración de mensajes de error
UNIQUE_ERR_MSG = {'unique': "Ya existe un registro con este nombre."}

# --- 1. CHOICES (Reemplazan los modelos de catálogo) ---

class RoleChoices(models.TextChoices):
    EMPLOYEE = 'EMP', 'Empleado'
    MANAGER = 'MGR', 'Manager'

class EmploymentTypeChoices(models.TextChoices):
    PERMANENT = 'FIJ', 'Fijo'
    TEMPORARY = 'TMP', 'Temporal'
    INTERNSHIP = 'PAS', 'Pasantía'

class EmploymentStatusChoices(models.TextChoices):
    ACTIVE = 'ACT', 'Activo'
    SUSPENDED = 'SUS', 'Suspendido'
    LEAVE = 'PER', 'De Permiso'
    REST = 'REP', 'Reposo'
    TERMINATED = 'FIN', 'Finalizado'
    RESIGNATION = 'REN', 'Renuncia'
    DISMISSAL = 'DES', 'Despido'
    CANCELLED = 'ANU', 'Anulado'

class HierarchicalRoleChoices(models.TextChoices):
    """Rol jerárquico dentro de un departamento"""
    MANAGER = 'MGR', 'Gerente'
    EMPLOYEE = 'EMP', 'Empleado'


def is_active_status(status_value):
    """
    Determina si un estatus representa una vinculación activa.
    Esto reemplaza el campo is_active_relationship del modelo anterior.
    """
    return status_value in [
        EmploymentStatusChoices.ACTIVE,
        EmploymentStatusChoices.SUSPENDED,
        EmploymentStatusChoices.LEAVE,
        EmploymentStatusChoices.REST,
    ]


# --- 2. MODELO PRINCIPAL (CONTRATO) ---

class Employment(models.Model):
    class ExitReason(models.TextChoices):
        RESIGNATION = 'REN', 'Renuncia Voluntaria'
        DISMISSAL = 'DES', 'Despido / Cese'
        END_CONTRACT = 'FIN', 'Fin de Contrato (Tiempo Cumplido)'
        RETIREMENT = 'JUB', 'Jubilación'
        DEATH = 'FAL', 'Fallecimiento'
        OTHER = 'OTR', 'Otro Motivo'

    # 1. EL DATO DURO (Para Estadísticas)
    exit_reason = models.CharField(
        max_length=3,
        choices=ExitReason.choices,
        null=True, blank=True,
        verbose_name="Motivo de Salida"
    )
    
    # 2. EL DATO BLANDO (Para Contexto)
    exit_notes = models.TextField(
        null=True, blank=True,
        verbose_name="Observaciones",
        help_text="Detalle o carta de renuncia."
    )

    person = models.ForeignKey(
        Person, 
        on_delete=models.CASCADE, 
        related_name='employments',
        verbose_name="Colaborador"
    )
    
    position = models.ForeignKey(
        Position, 
        on_delete=models.PROTECT, 
        related_name='employments',
        verbose_name="Cargo / Posición"
    )

    # CAMPOS CON CHOICES
    role = models.CharField(
        max_length=3,
        choices=RoleChoices.choices,
        default=RoleChoices.EMPLOYEE,
        verbose_name="Rol Funcional"
    )
    
    employment_type = models.CharField(
        max_length=3,
        choices=EmploymentTypeChoices.choices,
        default=EmploymentTypeChoices.PERMANENT,
        verbose_name="Tipo de Contrato"
    )
    
    current_status = models.CharField(
        max_length=3,
        choices=EmploymentStatusChoices.choices,
        default=EmploymentStatusChoices.ACTIVE,
        verbose_name="Estatus Actual"
    )
    
    hire_date = models.DateField(verbose_name="Fecha de Contratación")
    
    end_date = models.DateField(
        null=True, 
        blank=True, 
        help_text="Fecha de fin de contrato (para 'Tiempo Determinado' o 'Prueba')"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # Historial de cambios
    history = HistoricalRecords()

    # Lógica interna para detectar cambios
    __original_status = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Guardamos el valor del estatus original
        self.__original_status = self.current_status

    class Meta:
        verbose_name = "Expediente Laboral"
        ordering = ['-hire_date']

    def __str__(self):
        return f"{self.person} - {self.position}"

    def clean(self):
        # 1. Validar Fechas
        if self.end_date and self.hire_date and self.end_date < self.hire_date:
            raise ValidationError({'end_date': "La fecha de egreso no puede ser anterior a la fecha de ingreso."})

        # 2. VALIDACIÓN DE INTEGRIDAD (Usando is_active_status helper)
        
        # Si el estatus que intentamos guardar se considera "Activo/Vigente"...
        if self.current_status and is_active_status(self.current_status):
            
            # Buscamos conflictos: otros contratos activos del mismo empleado en la misma posición
            duplicates = Employment.objects.filter(
                person=self.person,
                position=self.position,
            ).exclude(pk=self.pk)  # Nos excluimos a nosotros mismos si estamos editando
            
            # Filtrar solo los que tienen estatus activo
            duplicates = [e for e in duplicates if is_active_status(e.current_status)]

            if duplicates:
                conflict = duplicates[0]
                raise ValidationError({
                    'current_status': f"Conflicto: {self.person} ya tiene un contrato vigente ({conflict.get_current_status_display()}) en el cargo '{self.position}'. Debe finalizar el anterior primero."
                })

    def save(self, *args, **kwargs):
        self.full_clean()
        
        # 2. LÓGICA DE FECHA DE FIN AUTOMÁTICA (Lo nuevo)
        if self.current_status:
            # Si el estatus NO es vigente (es finalizado/renuncia)...
            if not is_active_status(self.current_status):
                # ... y el usuario no puso fecha...
                if not self.end_date:
                    self.end_date = timezone.now().date() # ¡Asignamos HOY!
            
            # (Opcional) Si reactivas al empleado, limpiamos la fecha de fin

        # 3. DETECCIÓN DE CAMBIOS (Tu código original)
        is_created = self.pk is None
        
        # Verificamos si el valor del estatus cambió respecto al original cargado en __init__
        # Como current_status ahora es CharField, comparamos valores directamente
        original_status = getattr(self, '_Employment__original_status', None) 
        status_changed = self.current_status != self.__original_status

        # 4. DECREMENTO AUTOMÁTICO DE VACANTES (NUEVO)
        # Si es un nuevo contrato y el estatus es activo (ocupa silla)
        if is_created and is_active_status(self.current_status):
            # Bloqueamos la posición para evitar condiciones de carrera
            # Nota: select_for_update() requiere estar dentro de una transacción.
            # Como save() puede llamarse fuera, usamos F() expressions o asumimos transacción externa.
            # Para mayor seguridad y simplicidad aquí, usamos lógica directa, pero lo ideal es que
            # la vista/servicio envuelva esto en transaction.atomic()
            
            if self.position.vacancies > 0:
                self.position.vacancies -= 1
                self.position.save()
            # Si es 0, técnicamente no debería haber pasado la validación del serializer/clean,
            # pero por seguridad no restamos más allá de 0.

        # 5. GUARDADO REAL EN BASE DE DATOS
        super().save(*args, **kwargs)
        
        # 6. CREACIÓN DEL LOG (Tu código original)
        # Se hace DESPUÉS del super().save() para asegurar que tenemos un ID válido
        if is_created or status_changed:
            self._create_status_log(is_created)
            # Actualizamos el estado original en memoria para futuras ediciones en esta misma instancia
            self.__original_status = self.current_status

    def delete(self, *args, **kwargs):
        # 1. RESTITUCIÓN DE VACANTES
        # Si el contrato que se borra estaba ocupando plaza (activo), devolvemos la vacante.
        if is_active_status(self.current_status):
            self.position.vacancies += 1
            self.position.save()
            
        super().delete(*args, **kwargs)

    def _create_status_log(self, is_created):
        # 1. CASO: NUEVO INGRESO
        if is_created:
            reason_text = "Ingreso inicial / Contratación"
        
        # 2. CASO: FINALIZACIÓN DE CONTRATO (Salida)
        # Verificamos si el estatus actual indica cierre (usando helper function)
        elif self.current_status and not is_active_status(self.current_status):
            # Construimos el mensaje con los datos de salida que acabamos de guardar
            parts = []
            
            # A. Agregamos la categoría (ej. "Renuncia Voluntaria")
            if self.exit_reason:
                # get_FOO_display() es un método mágico de Django para obtener el texto del Choice
                parts.append(self.get_exit_reason_display())
            
            # B. Agregamos la nota específica si existe
            if self.exit_notes:
                parts.append(f"({self.exit_notes})")
            
            # Unimos todo. Si no hay nada, ponemos un default.
            reason_text = " ".join(parts) if parts else "Finalización de contrato (Sin motivo especificado)"

        # 3. CASO: CAMBIO ADMINISTRATIVO (Ej. Activo -> Suspendido, o Prueba -> Fijo)
        else:
            reason_text = "Cambio de estatus administrativo / Actualización"

        # --- GUARDAR EL LOG ---
        EmploymentStatusLog.objects.create(
            employment=self,
            status=self.current_status,
            start_date=timezone.now().date(), # O self.end_date si prefieres la fecha del evento
            reason=reason_text # <--- Aquí guardamos el texto calculado
        )
        
class EmploymentStatusLog(models.Model):
    employment = models.ForeignKey(
        Employment, 
        on_delete=models.CASCADE, 
        related_name='status_logs'
    )
    # Ahora es CharField porque usamos Choices
    status = models.CharField(
        max_length=3,
        choices=EmploymentStatusChoices.choices,
        verbose_name="Estatus"
    )
    start_date = models.DateField(
        default=timezone.now,
        help_text="Fecha de inicio de este estatus"
    )
    reason = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = "Historial de Estatus"
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.employment} - {self.get_status_display()} desde {self.start_date}"



# --- 4. ROL JERÁRQUICO EN DEPARTAMENTO ---

class EmploymentDepartmentRole(models.Model):
    """
    Define el rol jerárquico de un empleado en un departamento específico
    durante su contrato activo.
    
    Esto permite:
    - Que un empleado sea gerente de un departamento
    - Histórico de cambios de rol jerárquico
    - Roles temporales (con fecha de inicio y fin)
    - Roles matriciales (un empleado puede tener roles en múltiples departamentos)
    """
    employment = models.ForeignKey(
        Employment,
        on_delete=models.CASCADE,
        related_name='department_roles',
        verbose_name="Contrato",
        help_text="Contrato al que pertenece este rol jerárquico"
    )
    department = models.ForeignKey(
        'organization.Department',
        on_delete=models.CASCADE,
        related_name='employment_roles',
        verbose_name="Departamento",
        help_text="Departamento en el que ejerce este rol"
    )
    hierarchical_role = models.CharField(
        max_length=3,
        choices=HierarchicalRoleChoices.choices,
        default=HierarchicalRoleChoices.EMPLOYEE,
        verbose_name="Rol Jerárquico",
        help_text="Rol dentro del departamento (Gerente o Empleado)"
    )
    start_date = models.DateField(
        default=timezone.now,
        verbose_name="Fecha de Inicio",
        help_text="Inicio del rol jerárquico en este departamento"
    )
    end_date = models.DateField(
        null=True,
        blank=True,
        verbose_name="Fecha de Fin",
        help_text="Fin del rol jerárquico (NULL si es actual)"
    )
    notes = models.TextField(
        blank=True,
        null=True,
        verbose_name="Notas",
        help_text="Observaciones sobre la asignación del rol"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Historial de cambios
    history = HistoricalRecords()

    class Meta:
        verbose_name = "Rol Jerárquico en Departamento"
        verbose_name_plural = "Roles Jerárquicos en Departamentos"
        unique_together = ('employment', 'department', 'start_date')
        ordering = ['-start_date']

    def __str__(self):
        role_display = self.get_hierarchical_role_display()
        return f"{self.employment.person} - {role_display} de {self.department.name}"

    def clean(self):
        """Validaciones personalizadas"""
        super().clean()
        
        # Validar que el departamento del employment coincide con el department del rol
        # Validar que el departamento del employment coincide con el department del rol - REMOVED for Matrix Support
        # if self.employment.position and self.employment.position.department != self.department:
        #     raise ValidationError({
        #         'department': f'El departamento debe coincidir con el departamento de la posición del empleado ({self.employment.position.department.name})'
        #     })
        
        # Validar que end_date sea posterior a start_date
        if self.end_date and self.end_date < self.start_date:
            raise ValidationError({
                'end_date': 'La fecha de fin debe ser posterior a la fecha de inicio'
            })

    @property
    def is_current(self):
        """Verifica si el rol está actualmente vigente"""
        return self.end_date is None or self.end_date >= timezone.now().date()


# --- 5. ROL JERÁRQUICO POR PERSONA EN DEPARTAMENTO (MATRIZ) ---

class PersonDepartmentRole(models.Model):
    """
    Define el rol jerárquico de una persona en un departamento específico,
    independientemente de su contrato de trabajo.
    
    Este modelo permite organizaciones matriciales donde una persona puede
    tener un rol jerárquico en un departamento diferente al de su posición formal.
    
    Ventajas sobre EmploymentDepartmentRole:
    - Más flexible: Permite roles cruzados entre departamentos
    - Más simple: Vinculación directa Person→Department
    - Soporta matriz: Una persona en IT puede ser gerente de Finanzas
    """
    person = models.ForeignKey(
        'core.Person',
        on_delete=models.CASCADE,
        related_name='department_roles',
        verbose_name="Persona",
        help_text="Persona que ejerce este rol jerárquico"
    )
    department = models.ForeignKey(
        'organization.Department',
        on_delete=models.CASCADE,
        related_name='person_roles',
        verbose_name="Departamento",
        help_text="Departamento en el que ejerce este rol"
    )
    hierarchical_role = models.CharField(
        max_length=3,
        choices=HierarchicalRoleChoices.choices,
        default=HierarchicalRoleChoices.EMPLOYEE,
        verbose_name="Rol Jerárquico",
        help_text="Rol dentro del departamento (Gerente o Empleado)"
    )
    start_date = models.DateField(
        default=timezone.now,
        verbose_name="Fecha de Inicio",
        help_text="Inicio del rol jerárquico en este departamento"
    )
    end_date = models.DateField(
        null=True,
        blank=True,
        verbose_name="Fecha de Fin",
        help_text="Fin del rol jerárquico (NULL si es actual)"
    )
    notes = models.TextField(
        blank=True,
        null=True,
        verbose_name="Notas",
        help_text="Observaciones sobre la asignación del rol"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Historial de cambios
    history = HistoricalRecords()

    class Meta:
        verbose_name = "Rol Jerárquico por Persona"
        verbose_name_plural = "Roles Jerárquicos por Persona"
        unique_together = ('person', 'department', 'start_date')
        ordering = ['-start_date']

    def __str__(self):
        role_display = self.get_hierarchical_role_display()
        return f"{self.person.full_name} - {role_display} de {self.department.name}"

    def clean(self):
        """Validaciones personalizadas"""
        super().clean()
        
        # Validar que end_date sea posterior a start_date
        if self.end_date and self.end_date < self.start_date:
            raise ValidationError({
                'end_date': 'La fecha de fin debe ser posterior a la fecha de inicio'
            })

    @property
    def is_current(self):
        """Verifica si el rol está actualmente vigente"""
        return self.end_date is None or self.end_date >= timezone.now().date()
</file>

<file path="organization/models.py">
from django.db import models
from simple_history.models import HistoricalRecords

class Department(models.Model):
    name = models.CharField(max_length=100, unique=True)
    parent = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, related_name='subdepartments')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # Historial de cambios
    history = HistoricalRecords()

    def __str__(self):
        return self.name

class JobTitle(models.Model):
    name = models.CharField(max_length=100, unique=True)
    # description field removed
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # Historial de cambios
    history = HistoricalRecords()

    def __str__(self):
        return self.name

class Position(models.Model):
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True)
    job_title = models.ForeignKey(JobTitle, on_delete=models.SET_NULL, null=True)
    vacancies = models.PositiveIntegerField(default=1, help_text="Número de vacantes disponibles")
    
    # Objetivo del cargo (antes era un modelo separado)
    objective = models.TextField(
        blank=True, 
        null=True,
        help_text="Objetivo general del cargo",
        verbose_name="Objetivo"
    )
    
    # Reportes Matriciales: Una posición puede reportar a múltiples jefes
    manager_positions = models.ManyToManyField(
        'self',
        symmetrical=False,
        blank=True,
        related_name='direct_reports',
        help_text="Posiciones a las que reporta directamente (Jefes Inmediatos)."
    )

    is_manager = models.BooleanField(
        default=False,
        verbose_name="Es Gerencial",
        help_text="Indica si esta posición tiene responsabilidades gerenciales."
    )
    
    # name field removed
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # Historial de cambios
    history = HistoricalRecords()

    class Meta:
        unique_together = ('department', 'job_title')

    @property
    def title(self):
        """Nombre legible del cargo"""
        return f"{self.job_title.name} - {self.department.name}" if self.job_title and self.department else "Posición sin título"

    def __str__(self):
        if not self.job_title or not self.department:
            return "Posición incompleta"
        return f"{self.job_title.name} - {self.department.name}"


class PositionRequirement(models.Model):
    position = models.ForeignKey(Position, on_delete=models.CASCADE, related_name='requirements')
    description = models.TextField(help_text="Un requisito de la posición")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self): return self.description[:50]

class PositionFunction(models.Model):
    """Funciones y responsabilidades de un cargo"""
    position = models.ForeignKey(
        Position, 
        on_delete=models.CASCADE, 
        related_name='functions',
        help_text="Posición a la que pertenece esta función"
    )
    description = models.TextField(help_text="Descripción de la función o responsabilidad")
    order = models.PositiveIntegerField(
        default=0, 
        help_text="Orden de visualización (menor primero)"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['order', 'id']
        verbose_name = "Función de Cargo"
        verbose_name_plural = "Funciones de Cargos"
        
    def __str__(self):
        return f"{self.position} - Función #{self.order + 1}"
</file>

<file path="performance/models.py">
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator
from core.models import Person
from employment.models import Employment
from organization.models import JobTitle # Importamos JobTitle para la relación

class EvaluationPeriod(models.Model):
    """Define el ciclo de evaluación (Ej: 'Evaluación 2025-I')"""
    name = models.CharField(max_length=100, unique=True)
    start_date = models.DateField(verbose_name="Inicio")
    end_date = models.DateField(verbose_name="Cierre")
    is_active = models.BooleanField(default=True, verbose_name="Activo")
    
    class Meta:
        verbose_name = "Periodo de Evaluación"
        ordering = ['-start_date']

    def __str__(self): return self.name

class Competency(models.Model):
    """
    Diccionario de criterios a evaluar.
    """
    class Category(models.TextChoices):
        QUALITY = 'CAL', 'Calidad'
        COMMITMENT = 'COM', 'Compromiso'
        COMMUNICATION = 'CMU', 'Comunicación'
        ORGANIZATION = 'ORG', 'Organización'
        DISCIPLINE = 'DIS', 'Disciplina'
        PROACTIVITY = 'PRO', 'Proactividad'
    
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True, null=True)
    
    # NUEVA CATEGORÍA: Para agrupar competencias según performance.md
    category = models.CharField(
        max_length=3,
        choices=Category.choices,
        blank=True,
        null=True,
        verbose_name="Categoría",
        help_text="Categoría de evaluación según la matriz de desempeño global",
        db_index=True  # Índice para mejorar rendimiento en queries por categoría
    )
    
    # LÓGICA DE SEGMENTACIÓN
    is_global = models.BooleanField(
        default=True, 
        verbose_name="¿Es Global?",
        help_text="Si se marca, aplica a todos los empleados."
    )
    
    # Relación con Títulos de Cargo (NO con Posiciones individuales)
    job_titles = models.ManyToManyField(
        JobTitle, 
        blank=True, 
        related_name='specific_competencies',
        verbose_name="Aplica a Cargos Específicos"
    )

    class Meta:
        verbose_name = "Competencia / Criterio"
        verbose_name_plural = "Competencias"

    def __str__(self): return self.name

class PerformanceReview(models.Model):
    """La boleta de evaluación de un CONTRATO específico."""
    
    class Status(models.TextChoices):
        DRAFT = 'BOR', 'Borrador'
        SUBMITTED = 'ENV', 'Enviada / Finalizada'
        ACKNOWLEDGED = 'ACE', 'Aceptada por Empleado'

    period = models.ForeignKey(EvaluationPeriod, on_delete=models.PROTECT)
    
    # Evaluamos al CONTRATO (Employment), para soportar pluriempleo
    employment = models.ForeignKey(
        Employment, 
        on_delete=models.CASCADE, 
        related_name='reviews'
    )
    
    # El evaluador es el JEFE en ese momento
    evaluator = models.ForeignKey(
        Person, 
        on_delete=models.PROTECT, 
        related_name='reviews_given'
    )
    
    final_score = models.DecimalField(
        max_digits=4, decimal_places=2, 
        null=True, blank=True, 
        verbose_name="Promedio Final"
    )
    
    status = models.CharField(max_length=3, choices=Status.choices, default=Status.DRAFT)
    
    feedback_manager = models.TextField(verbose_name="Comentarios del Jefe", blank=True)
    feedback_employee = models.TextField(verbose_name="Comentarios del Empleado", blank=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        # Un contrato solo puede ser evaluado una vez por periodo
        unique_together = ('period', 'employment') 
        verbose_name = "Evaluación de Desempeño"
        verbose_name_plural = "Evaluaciones de Desempeño"

    def __str__(self):
        return f"{self.employment.person} - {self.period}"
        
    def calculate_score(self):
        """Recalcula el promedio."""
        details = self.details.all()
        if not details.exists():
            self.final_score = 0
        else:
            total = sum([d.score for d in details])
            self.final_score = total / details.count()
        self.save()

class ReviewDetail(models.Model):
    """Cada pregunta y su respuesta."""
    review = models.ForeignKey(PerformanceReview, on_delete=models.CASCADE, related_name='details')
    competency = models.ForeignKey(Competency, on_delete=models.PROTECT)
    
    score = models.PositiveIntegerField(
        default=0,
        validators=[MinValueValidator(0), MaxValueValidator(5)],
        verbose_name="Puntaje (1-5)"
    )
    comment = models.TextField(blank=True, null=True, verbose_name="Observación")

    class Meta:
        unique_together = ('review', 'competency')

    def __str__(self):
        return f"{self.competency}: {self.score}"
</file>

<file path="recruitment/models.py">
from django.db import models

# Create your models here.
</file>

<file path="talent/models.py">
from django.db import models
from core.models import Person

# Mensajes de error estándar
UNIQUE_ERR_MSG = {'unique': "Ya existe un registro con este nombre."}

class BusinessFunction(models.Model):
    name = models.CharField(
        max_length=100, 
        unique=True, 
        help_text="Ej: Human Resources, Finance, IT",
        error_messages=UNIQUE_ERR_MSG
    )
    description = models.TextField(blank=True, null=True)
    def __str__(self): return self.name

class EducationLevel(models.Model):
    name = models.CharField(
        max_length=100, 
        unique=True, 
        help_text="Ej: Ingeniería, Maestría, Bachillerato",
        error_messages=UNIQUE_ERR_MSG
    )
    def __str__(self): return self.name

class FieldOfStudy(models.Model):
    education_level = models.ForeignKey(
        EducationLevel, 
        on_delete=models.CASCADE, 
        related_name='fields_of_study',
        null=True,  # Permitir NULL para registros existentes
        blank=True,
        help_text="Nivel educativo al que pertenece este campo de estudio"
    )
    name = models.CharField(
        max_length=100, 
        help_text="Ej: Software, Recursos Humanos, Diseño Gráfico",
        error_messages=UNIQUE_ERR_MSG
    )
    
    class Meta:
        unique_together = ('education_level', 'name')
    
    def __str__(self): 
        if self.education_level:
            return f"{self.name} ({self.education_level.name})"
        return self.name

# --- Modelos Transaccionales ---

class PersonSpecialAssignment(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name='special_assignments')
    project_name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self): return self.project_name

class PersonFunctionalExperience(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name='functional_experiences')
    function = models.ForeignKey(BusinessFunction, on_delete=models.SET_NULL, null=True)
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True, help_text="NULL si es actual")
    comments = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self): return f"{self.person} - {self.function}"

class PersonCertification(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name='certifications')
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    institution = models.CharField(max_length=255)
    effective_date = models.DateField()
    expiration_date = models.DateField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self): return self.name

class CertificationDocument(models.Model):
    certification = models.ForeignKey(PersonCertification, on_delete=models.CASCADE, related_name='documents')
    file = models.FileField(upload_to='documents/certification/', blank=True, null=True)
    description = models.CharField(max_length=255, blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self): return self.description or "Documento de Certificación"

class PersonEducation(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name='education_history')
    school_name = models.CharField(max_length=255)
    level = models.ForeignKey(EducationLevel, on_delete=models.SET_NULL, null=True)
    field_of_study = models.ForeignKey(FieldOfStudy, on_delete=models.SET_NULL, null=True)
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self): return f"{self.school_name} - {self.level}"

class PersonVolunteerExperience(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name='volunteer_experiences')
    organization_name = models.CharField(max_length=255)
    role = models.CharField(max_length=255)
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self): return f"{self.organization_name} ({self.role})"

class PersonAward(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name='awards')
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    institution = models.CharField(max_length=255, blank=True, null=True)
    issue_date = models.DateField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self): return self.name

class PersonMembership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name='memberships')
    organization_name = models.CharField(max_length=255)
    role = models.CharField(max_length=255, blank=True, null=True)
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self): return self.organization_name

class Language(models.Model):
    name = models.CharField(max_length=100, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class LanguageProficiency(models.Model):
    name = models.CharField(max_length=50, unique=True, error_messages=UNIQUE_ERR_MSG)
    def __str__(self): return self.name

class PersonLanguage(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="languages")
    language = models.ForeignKey(Language, on_delete=models.CASCADE)
    speaking_proficiency = models.ForeignKey(LanguageProficiency, on_delete=models.SET_NULL, null=True, blank=True, related_name="speaking")
    reading_proficiency = models.ForeignKey(LanguageProficiency, on_delete=models.SET_NULL, null=True, blank=True, related_name="reading")
    writing_proficiency = models.ForeignKey(LanguageProficiency, on_delete=models.SET_NULL, null=True, blank=True, related_name="writing")

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=['person', 'language'],
                name='unique_person_language',
                violation_error_message="Esta persona ya tiene registrado este idioma."
            )
        ]

    def __str__(self): return f"{self.person} - {self.language}"
</file>

<file path="training/models.py">
from django.db import models
from django.core.exceptions import ValidationError
from core.models import Person

class Course(models.Model):
    class Status(models.TextChoices):
        DRAFT = 'BOR', 'Borrador'
        SCHEDULED = 'PRO', 'Programado'
        IN_PROGRESS = 'EJE', 'En Ejecución'
        COMPLETED = 'FIN', 'Finalizado'
        CANCELLED = 'CAN', 'Cancelado'

    # NUEVO: Modalidad
    class Modality(models.TextChoices):
        PRESENTIAL = 'PRE', 'Presencial'
        VIRTUAL_SYNC = 'VIR', 'Virtual (En Vivo / Zoom)'
        VIRTUAL_ASYNC = 'ASY', 'Virtual (Autoaprendizaje)'
        HYBRID = 'MIX', 'Híbrido / Mixto'

    name = models.CharField(max_length=200, verbose_name="Nombre del Curso")
    description = models.TextField(blank=True, null=True)

    cover_image = models.ImageField(
        upload_to='courses/covers/', 
        null=True, 
        blank=True,
        verbose_name="Imagen de Portada"
    )
    
    start_date = models.DateField(verbose_name="Fecha Inicio")
    end_date = models.DateField(verbose_name="Fecha Fin")
    
    # NUEVO: Modalidad y Cupo
    modality = models.CharField(max_length=3, choices=Modality.choices, default=Modality.PRESENTIAL)
    max_participants = models.PositiveIntegerField(
        default=20, 
        verbose_name="Cupo Máximo",
        help_text="Límite de estudiantes permitidos."
    )
    
    duration_hours = models.PositiveIntegerField(default=0)
    status = models.CharField(max_length=3, choices=Status.choices, default=Status.DRAFT)
    
    # 🔧 REFACTOR: Instructor es ahora un campo directo del curso
    instructor = models.ForeignKey(
        Person,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='courses_taught',
        verbose_name="Instructor"
    )
    
    # Privacy/Visibility settings
    is_public = models.BooleanField(
        default=True,
        verbose_name="Curso Público",
        help_text="Si es público, todos pueden ver el curso. Si es privado, solo el departamento asignado."
    )
    department = models.ForeignKey(
        'organization.Department',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='courses',
        verbose_name="Departamento",
        help_text="Departamento al que pertenece este curso (solo si es privado)"
    )
    
    # 🆕 NEW: Grading Logic
    requires_approval_to_complete = models.BooleanField(
        default=False,
        verbose_name="Requiere Aprobación Manual",
        help_text="Si es True, el instructor debe asignar nota manualmente. Si es False, se completa automáticamente al terminar todas las lecciones."
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self): return self.name
    
    @property
    def enrolled_count(self):
        # 🔧 REFACTOR: Ahora solo contamos estudiantes inscritos (todos los participants son estudiantes)
        return self.participants.filter(enrollment_status='ENR').count()

    @property
    def is_full(self):
        return self.enrolled_count >= self.max_participants


class CourseResource(models.Model):
    """Materiales de apoyo (PDFs, Videos, Links)."""
    
    class Type(models.TextChoices):
        FILE = 'FIL', 'Archivo (PDF/Doc/Img)'
        LINK = 'URL', 'Enlace Externo / Video'

    course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name='resources')
    # 🆕 NEW: Link resource to a specific lesson (optional, can be course-level)
    lesson = models.ForeignKey('CourseLesson', on_delete=models.CASCADE, related_name='resources', null=True, blank=True)
    name = models.CharField(max_length=200, verbose_name="Título del Recurso")
    resource_type = models.CharField(max_length=3, choices=Type.choices, default=Type.FILE)
    
    # Puede ser uno U otro
    file = models.FileField(upload_to='training/resources/', null=True, blank=True)
    url = models.URLField(null=True, blank=True, help_text="Youtube, Drive, Zoom, etc.")
    
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self): return self.name


class CourseSession(models.Model):
    """
    Cada una de las clases o sesiones del curso.
    Necesario para tomar asistencia por día en cursos Presenciales/Híbridos.
    """
    course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name='sessions')
    topic = models.CharField(max_length=200, verbose_name="Tema / Título de la Sesión")
    date = models.DateField(verbose_name="Fecha de la sesión")
    start_time = models.TimeField(verbose_name="Hora Inicio")
    end_time = models.TimeField(verbose_name="Hora Fin")
    
    class Meta:
        ordering = ['date', 'start_time']

    def __str__(self): return f"{self.course.name} - {self.topic} ({self.date})"


# 🆕 NEW: Hierarchical Content Models
class CourseModule(models.Model):
    """
    Módulos del curso para organizar el contenido de forma jerárquica.
    Cada módulo contiene múltiples lecciones.
    """
    course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name='modules')
    name = models.CharField(max_length=200, verbose_name="Nombre del Módulo")
    description = models.TextField(blank=True, null=True, verbose_name="Descripción")
    order = models.PositiveIntegerField(default=0, verbose_name="Orden")
    
    class Meta:
        ordering = ['order']
        unique_together = ['course', 'order']
        verbose_name = "Módulo del Curso"
        verbose_name_plural = "Módulos del Curso"
    
    def __str__(self): return f"{self.course.name} - {self.name}"


class CourseLesson(models.Model):
    """
    Lecciones individuales dentro de un módulo.
    Contiene el contenido educativo real.
    """
    module = models.ForeignKey(CourseModule, on_delete=models.CASCADE, related_name='lessons')
    title = models.CharField(max_length=200, verbose_name="Título de la Lección")
    content = models.TextField(verbose_name="Contenido", help_text="Contenido en formato de texto enriquecido", blank=True, null=True)
    # 🔧 REFACTOR: Resources (files/urls) are now in CourseResource model linked to this lesson
    order = models.PositiveIntegerField(default=0, verbose_name="Orden")
    duration_minutes = models.PositiveIntegerField(default=0, verbose_name="Duración (minutos)")
    
    class Meta:
        ordering = ['order']
        unique_together = ['module', 'order']
        verbose_name = "Lección"
        verbose_name_plural = "Lecciones"
    
    def __str__(self): return f"{self.module.name} - {self.title}"


class CourseParticipant(models.Model):
    """
    🔧 REFACTOR: CourseParticipant ahora solo almacena ESTUDIANTES.
    Los instructores se asignan directamente en Course.instructor.
    
    ⚠️ PENDING RENAME: Este modelo será renombrado a 'Enrollment' en una migración posterior.
    """
    
    class EnrollmentStatus(models.TextChoices):
        REQUESTED = 'REQ', 'Solicitud Enviada'
        ENROLLED = 'ENR', 'Inscrito'
        REJECTED = 'REJ', 'Solicitud Rechazada'

    class AcademicStatus(models.TextChoices):
        PENDING = 'PEN', 'En Curso'
        COMPLETED = 'COM', 'Completado'
        PASSED = 'APR', 'Aprobado'
        FAILED = 'REP', 'Reprobado'

    course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name='participants')
    person = models.ForeignKey(Person, on_delete=models.CASCADE, related_name='training_courses')
    
    # Campos de estado (solo para estudiantes)
    enrollment_status = models.CharField(
        max_length=3, 
        choices=EnrollmentStatus.choices, 
        default=EnrollmentStatus.REQUESTED,
        verbose_name="Estado de Inscripción"
    )
    academic_status = models.CharField(
        max_length=3, 
        choices=AcademicStatus.choices, 
        default=AcademicStatus.PENDING,
        verbose_name="Estado Académico"
    )
    
    grade = models.DecimalField(max_digits=5, decimal_places=2, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="Fecha de Solicitud")
    
    class Meta:
        unique_together = ('course', 'person')

    def __str__(self): return f"{self.person} en {self.course}"


# 🆕 NEW: Lesson Progress Tracking
class LessonProgress(models.Model):
    """
    Rastrea el progreso de cada estudiante en cada lección.
    Se usa para calcular el porcentaje de completitud y determinar si el curso está completo.
    """
    enrollment = models.ForeignKey(
        CourseParticipant,  # Will reference 'Enrollment' after rename
        on_delete=models.CASCADE,
        related_name='lesson_progress'
    )
    lesson = models.ForeignKey(CourseLesson, on_delete=models.CASCADE, related_name='progress_records')
    completed = models.BooleanField(default=False, verbose_name="Completada")
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name="Fecha de Completitud")
    
    class Meta:
        unique_together = ['enrollment', 'lesson']
        verbose_name = "Progreso de Lección"
        verbose_name_plural = "Progreso de Lecciones"
    
    def __str__(self): 
        return f"{self.enrollment.person} - {self.lesson.title} ({'✓' if self.completed else '✗'})"


class AttendanceRecord(models.Model):
    """Registro de asistencia: Cruce entre Sesión y Participante."""
    
    class Status(models.TextChoices):
        PRESENT = 'PRE', 'Presente'
        ABSENT = 'AUS', 'Ausente'
        LATE = 'TAR', 'Tardanza'
        EXCUSED = 'JUS', 'Justificado'

    session = models.ForeignKey(CourseSession, on_delete=models.CASCADE, related_name='attendance_records')
    participant = models.ForeignKey(CourseParticipant, on_delete=models.CASCADE, related_name='attendance_history')
    
    status = models.CharField(max_length=3, choices=Status.choices, default=Status.ABSENT)
    notes = models.CharField(max_length=255, blank=True, null=True)
    
    class Meta:
        unique_together = ('session', 'participant') # Solo una asistencia por persona por sesión

    def __str__(self): return f"{self.participant.person} - {self.session} : {self.get_status_display()}"
</file>

</files>
